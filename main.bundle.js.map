{"version":3,"file":"main.bundle.js","mappings":"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","sources":["webpack://battleship/./src/components/Ship.js","webpack://battleship/./src/components/Gameboard.js","webpack://battleship/./src/components/Player.js","webpack://battleship/./src/GameController.js","webpack://battleship/./src/components/ComputerPlayer.js","webpack://battleship/./src/DomController.js","webpack://battleship/./src/AppController.js"],"sourcesContent":["export const Ship = (length, direction, startRow, startCol) => {\n   let hits = 0;\n\n   const getHits = () => hits;\n   const hit = () => {\n      ++hits;\n   };\n   const isSunk = () => hits >= length;\n   return {\n      length,\n      direction,\n      startRow,\n      startCol,\n      getHits,\n      hit,\n      isSunk,\n   };\n};\n","import { Ship } from \"./Ship\";\n\nexport const Gameboard = (size) => {\n   const board = Array.from({ length: size }, () => Array(size).fill(null));\n   const ships = [];\n\n   const getCell = (row, col) => board[row][col];\n   const hasShip = (row, col) => getCell(row, col) !== null;\n   const getAllShips = () => [...ships];\n   const isAllShipsSunken = () => ships.every((ship) => ship.isSunk());\n   const getGrid = () => board;\n\n   const getShipPositions = () =>\n      ships.map(({ startRow, startCol, length, direction }) => ({\n         startRow,\n         startCol,\n         length,\n         direction,\n      }));\n\n   const getShipIndex = (row, col) => {\n      return (\n         ships.find((ship) => {\n            const { startRow, startCol, length, direction } = ship;\n            if (direction === \"horizontal\") {\n               return row === startRow && col >= startCol && col < startCol + length;\n            } else {\n               return col === startCol && row >= startRow && row < startRow + length;\n            }\n         }) || undefined\n      );\n   };\n\n   const getShip = (row, col) => {\n      const index = board[row][col];\n      return Number.isInteger(index) ? ships[index] : undefined;\n   };\n\n   const _isValidPlacement = (row, col, length, direction) => {\n      if (direction === \"horizontal\" && col + length > size) return false;\n      if (direction === \"vertical\" && row + length > size) return false;\n\n      for (let i = 0; i < length; i++) {\n         const newRow = direction === \"vertical\" ? row + i : row;\n         const newCol = direction === \"horizontal\" ? col + i : col;\n         if (hasShip(newRow, newCol)) return false;\n      }\n      return true;\n   };\n\n   const placeShip = (row, col, length, direction) => {\n      if (!_isValidPlacement(row, col, length, direction)) {\n         throw new Error(\"Invalid placement: Out of bounds or overlapping.\");\n      }\n\n      const ship = Ship(length, direction, row, col);\n      const shipIndex = ships.length;\n      ships.push(ship);\n\n      for (let i = 0; i < length; i++) {\n         const newRow = direction === \"vertical\" ? row + i : row;\n         const newCol = direction === \"horizontal\" ? col + i : col;\n         board[newRow][newCol] = shipIndex;\n      }\n   };\n\n   const receiveAttack = (row, col) => {\n      const cell = getCell(row, col);\n      if (cell === null) {\n         board[row][col] = \"X\"; // Missed shot\n         return \"X\";\n      }\n      if (Number.isInteger(cell)) {\n         const ship = getShip(row, col);\n         if (ship) {\n            ship.hit();\n            board[row][col] = \"H\";\n            return \"H\";\n         }\n      }\n      // throw new Error(\"This cell was already attacked.\");\n      console.log(\"Cell already attacked... Skipping...\");\n      return \"Cell already attacked... Skipping...\";\n   };\n\n   return {\n      placeShip,\n      getCell,\n      hasShip,\n      getShip,\n      getAllShips,\n      receiveAttack,\n      isAllShipsSunken,\n      getGrid,\n      getShipPositions,\n      getShipIndex,\n   };\n};\n","import { Gameboard } from \"./Gameboard\";\n\nexport const Player = (name) => {\n   const ownBoard = Gameboard(10);\n\n   return {\n      name,\n      ownBoard,\n   };\n};\n","import { Player } from \"./components/Player\";\nimport { ComputerPlayer } from \"./components/ComputerPlayer\";\nimport { gameOver, passCellDisplayInfo, passTurnInfo } from \"./AppController\";\n\nconst cpuPlayer = ComputerPlayer();\nexport const player1 = Player(\"player-1\");\n// player1.ownBoard.placeShip(4, 3, 2, \"horizontal\");\nplayer1.ownBoard.placeShip(4, 3, 5, \"horizontal\");\nplayer1.ownBoard.placeShip(6, 4, 4, \"vertical\");\nplayer1.ownBoard.placeShip(2, 1, 3, \"horizontal\");\nplayer1.ownBoard.placeShip(1, 8, 2, \"vertical\");\nplayer1.ownBoard.placeShip(0, 4, 3, \"horizontal\");\nplayer1.ownBoard.placeShip(8, 6, 3, \"horizontal\");\n// // additional ships for testing...\n// player1.ownBoard.placeShip(0, 0, 3, \"horizontal\");\n// player1.ownBoard.placeShip(1, 1, 6, \"horizontal\");\n// player1.ownBoard.placeShip(3, 1, 6, \"horizontal\");\n\nexport const player2 = Player(\"player-2\");\nplayer2.ownBoard.placeShip(0, 1, 5, \"horizontal\");\nplayer2.ownBoard.placeShip(3, 2, 4, \"vertical\");\nplayer2.ownBoard.placeShip(7, 5, 3, \"vertical\");\nplayer2.ownBoard.placeShip(5, 5, 3, \"horizontal\");\nplayer2.ownBoard.placeShip(2, 6, 2, \"horizontal\");\nplayer2.ownBoard.placeShip(2, 4, 2, \"vertical\");\n\n// export const handleCpuTurn = (cpuPlayer) => {\n//    let currentPlayer = takeTurns.getCurrentPlayer();\n//    let opponent = currentPlayer === player1 ? player2 : player1;\n//    const {\n//       getState,\n//       setState,\n//       getLastHit,\n//       setLastHit,\n//       addPotentialTargets,\n//       getNextTarget,\n//       getPotentialTargets,\n//       clearPotentialTargets,\n//       hasCellBeenAttacked,\n//       markCellAsAttacked,\n//       getShipOrientation,\n//       setShipOrientation,\n//    } = cpuPlayer;\n\n//    let randomRow, randomCol;\n\n//    if (getState() === \"hunt\") {\n//       do {\n//          ({ randomRow, randomCol } = _randomizeCoords());\n//       } while (hasCellBeenAttacked(randomRow, randomCol));\n//       const result = runGame(randomRow, randomCol);\n\n//       markCellAsAttacked(randomRow, randomCol);\n\n//       if (result === \"H\") {\n//          const shipToCheck = opponent.ownBoard.getShipIndex(randomRow, randomCol);\n//          if (shipToCheck && shipToCheck.isSunk()) {\n//             console.log(`Ship at (${randomRow}, ${randomCol}) is sunk! Resetting to hunt mode...`);\n//             setState(\"hunt\");\n//             setLastHit(null);\n//             setShipOrientation(null);\n//             clearPotentialTargets();\n//          } else {\n//             setState(\"target\");\n//             setLastHit(randomRow, randomCol);\n//             addPotentialTargets(_getAdjacentCells(randomRow, randomCol));\n//          }\n//       }\n//    } else if (getState() === \"target\") {\n//       let nextTarget = getNextTarget();\n//       do {\n//          nextTarget = getNextTarget();\n//       } while (nextTarget !== null && hasCellBeenAttacked(nextTarget.row, nextTarget.col));\n\n//       if (nextTarget !== null) {\n//          const { row: nextRow, col: nextCol } = nextTarget;\n//          const result = runGame(nextRow, nextCol);\n//          markCellAsAttacked(nextRow, nextCol);\n\n//          if (result === \"H\") {\n//             const shipToCheck = opponent.ownBoard.getShipIndex(nextRow, nextCol);\n//             if (shipToCheck && shipToCheck.isSunk()) {\n//                console.log(`Ship at (${nextRow}, ${nextCol}) is sunk! Resetting to hunt mode...`);\n//                setState(\"hunt\");\n//                setLastHit(null);\n//                setShipOrientation(null);\n//                clearPotentialTargets();\n//             } else {\n//                if (getShipOrientation() === null) {\n//                   const { row: lastRow, col: lastCol } = getLastHit();\n//                   if (nextRow === lastRow) {\n//                      setShipOrientation(\"horizontal\");\n//                   } else if (nextCol === lastCol) {\n//                      setShipOrientation(\"vertical\");\n//                   }\n//                   console.log(`detected ship orientation: ${getShipOrientation()}.`);\n//                }\n\n//                // Add more targets along the detected orientation\n//                if (getShipOrientation() === \"horizontal\") {\n//                   const left = { row: nextRow, col: nextCol - 1 };\n//                   const right = { row: nextRow, col: nextCol + 1 };\n//                   [left, right].forEach((cell) => {\n//                      if (\n//                         cell.row >= 0 &&\n//                         cell.row < 10 &&\n//                         cell.col >= 0 &&\n//                         cell.col < 10 &&\n//                         !hasCellBeenAttacked(cell.row, cell.col)\n//                      ) {\n//                         addPotentialTargets([cell]);\n//                      }\n//                   });\n//                } else if (getShipOrientation() === \"vertical\") {\n//                   const up = { row: nextRow - 1, col: nextCol };\n//                   const down = { row: nextRow + 1, col: nextCol };\n//                   [up, down].forEach((cell) => {\n//                      if (\n//                         cell.row >= 0 &&\n//                         cell.row < 10 &&\n//                         cell.col >= 0 &&\n//                         cell.col < 10 &&\n//                         !hasCellBeenAttacked(cell.row, cell.col)\n//                      ) {\n//                         addPotentialTargets([cell]);\n//                      }\n//                   });\n//                }\n//             }\n//          } else if (result === \"X\") {\n//             console.log(`that's a miss! waiting for next Computer player turn...`);\n//          }\n//       } else {\n//          console.log(\"No more valid targets! Resetting to hunt mode...\");\n//          setState(\"hunt\");\n//          setLastHit(null);\n//          setShipOrientation(null);\n//          clearPotentialTargets();\n//          console.log(`cleared potential targets list: ${JSON.stringify(getPotentialTargets())}.`);\n//       }\n//    }\n// };\n\n// export const handleCpuTurn = (cpuPlayer) => {\n//    let currentPlayer = takeTurns.getCurrentPlayer();\n//    let opponent = currentPlayer === player1 ? player2 : player1;\n//    const {\n//       getState,\n//       setState,\n//       getLastHit,\n//       setLastHit,\n//       addPotentialTargets,\n//       getNextTarget,\n//       getPotentialTargets,\n//       clearPotentialTargets,\n//       hasCellBeenAttacked,\n//       markCellAsAttacked,\n//       getShipOrientation,\n//       setShipOrientation,\n//    } = cpuPlayer;\n\n//    let randomRow, randomCol;\n\n//    if (getState() === \"hunt\") {\n//       do {\n//          ({ randomRow, randomCol } = _randomizeCoords());\n//       } while (hasCellBeenAttacked(randomRow, randomCol));\n//       const result = runGame(randomRow, randomCol);\n\n//       markCellAsAttacked(randomRow, randomCol);\n\n//       if (result === \"H\") {\n//          const shipTocheck = opponent.ownBoard.getShipIndex(randomRow, randomCol);\n//          if (shipTocheck) {\n//             console.log(`ship at (${randomRow}, ${randomCol}) is sunk?`, shipTocheck.isSunk());\n//          }\n//          setState(\"target\");\n//          setLastHit(randomRow, randomCol);\n//          addPotentialTargets(_getAdjacentCells(randomRow, randomCol));\n//       }\n//    } else if (getState() === \"target\") {\n//       let nextTarget = getNextTarget();\n//       do {\n//          nextTarget = getNextTarget();\n//       } while (nextTarget !== null && hasCellBeenAttacked(nextTarget.row, nextTarget.col));\n\n//       if (nextTarget !== null) {\n//          const { row: nextRow, col: nextCol } = nextTarget;\n//          const result = runGame(nextRow, nextCol);\n//          markCellAsAttacked(nextRow, nextCol);\n\n//          if (result === \"H\") {\n//             if (getShipOrientation() === null) {\n//                const { row: lastRow, col: lastCol } = getLastHit();\n//                if (nextRow === lastRow) {\n//                   setShipOrientation(\"horizontal\");\n//                } else if (nextCol === lastCol) {\n//                   setShipOrientation(\"vertical\");\n//                }\n//                console.log(`detected ship orientatio: ${getShipOrientation()}.`);\n//             }\n//             // Add more targets along the detected orientation\n//             if (getShipOrientation() === \"horizontal\") {\n//                const left = { row: nextRow, col: nextCol - 1 };\n//                const right = { row: nextRow, col: nextCol + 1 };\n//                [left, right].forEach((cell) => {\n//                   if (\n//                      cell.row >= 0 &&\n//                      cell.row < 10 &&\n//                      cell.col >= 0 &&\n//                      cell.col < 10 &&\n//                      !hasCellBeenAttacked(cell.row, cell.col)\n//                   ) {\n//                      addPotentialTargets([cell]);\n//                   }\n//                });\n//             } else if (getShipOrientation() === \"vertical\") {\n//                const up = { row: nextRow - 1, col: nextCol };\n//                const down = { row: nextRow + 1, col: nextCol };\n//                [up, down].forEach((cell) => {\n//                   if (\n//                      cell.row >= 0 &&\n//                      cell.row < 10 &&\n//                      cell.col >= 0 &&\n//                      cell.col < 10 &&\n//                      !hasCellBeenAttacked(cell.row, cell.col)\n//                   ) {\n//                      addPotentialTargets([cell]);\n//                   }\n//                });\n//             }\n//          } else if (result === \"X\") {\n//             console.log(`thats a miss! waiting for next Computer player turn...`);\n//             // Continue targeting by moving to the next potential target\n//             // No action needed here; the loop will handle the next target\n//          }\n//       } else {\n//          console.log(\"Normally reset. But NOT now.\");\n\n//          // if (opponent.ownBoard.hasShip(randomRow, randomCol)) {\n//          //    console.log(randomRow, randomCol);\n//          // }\n//          // console.log(`The ship's sunk! resetting the status of ${getState()}...`);\n//          // setState(\"hunt\");\n//          // setLastHit(null);\n//          // setShipOrientation(null);\n//          // console.log(\n//          //    `resetting has been done. now we are back to the status of ${getState()}, and the last hit was reset back to null.`,\n//          // );\n//          // clearPotentialTargets();\n//          // console.log(`cleared potential targets list: ${JSON.stringify(getPotentialTargets())}.`);\n//       }\n//    }\n//    // const currentPlayer = takeTurns.getCurrentPlayer();\n//    // console.log(player2.ownBoard.getShip(randomRow, randomCol));\n//    // console.log(currentPlayer.ownBoard.getShip(randomRow, randomCol));\n//    // console.log(player1.ownBoard.getShip(randomRow, randomCol));\n//    // if (currentPlayer === player1) {\n//    // const currentShip = currentPlayer.ownBoard.getShip(randomRow, randomCol);\n//    // if (currentShip) {\n//    //    console.log(currentShip.isSunk());\n//    // }\n//    // }\n// };\n\n// Helper function to reset the computer player's state\n\n/* REFACTORING handleCpuTurn BEGINS */\n\nconst resetComputerPlayer = (cpuPlayer) => {\n   const { setState, setLastHit, setShipOrientation, clearPotentialTargets } = cpuPlayer;\n   setState(\"hunt\");\n   setLastHit(null);\n   setShipOrientation(null);\n   clearPotentialTargets();\n   console.log(\"Computer player reset to hunt mode.\");\n};\n\nconst addTargetsAlongOrientation = (cpuPlayer, row, col) => {\n   const { addPotentialTargets, getShipOrientation, hasCellBeenAttacked } = cpuPlayer;\n\n   if (getShipOrientation() === \"horizontal\") {\n      const left = { row, col: col - 1 };\n      const right = { row, col: col + 1 };\n      [left, right].forEach((cell) => {\n         if (\n            cell.row >= 0 &&\n            cell.row < 10 &&\n            cell.col >= 0 &&\n            cell.col < 10 &&\n            !hasCellBeenAttacked(cell.row, cell.col)\n         ) {\n            addPotentialTargets([cell]);\n         }\n      });\n   } else if (getShipOrientation() === \"vertical\") {\n      const up = { row: row - 1, col };\n      const down = { row: row + 1, col };\n      [up, down].forEach((cell) => {\n         if (\n            cell.row >= 0 &&\n            cell.row < 10 &&\n            cell.col >= 0 &&\n            cell.col < 10 &&\n            !hasCellBeenAttacked(cell.row, cell.col)\n         ) {\n            addPotentialTargets([cell]);\n         }\n      });\n   }\n};\n\nconst handleHuntMode = (cpuPlayer, opponent) => {\n   const { setState, setLastHit, addPotentialTargets, hasCellBeenAttacked, markCellAsAttacked } =\n      cpuPlayer;\n\n   let randomRow, randomCol;\n   do {\n      ({ randomRow, randomCol } = _randomizeCoords());\n   } while (hasCellBeenAttacked(randomRow, randomCol));\n\n   const result = runGame(randomRow, randomCol);\n   markCellAsAttacked(randomRow, randomCol);\n\n   if (result === \"H\") {\n      const shipToCheck = opponent.ownBoard.getShipIndex(randomRow, randomCol);\n      if (shipToCheck && shipToCheck.isSunk()) {\n         console.log(`Ship at (${randomRow}, ${randomCol}) is sunk! Resetting to hunt mode...`);\n         resetComputerPlayer(cpuPlayer);\n      } else {\n         setState(\"target\");\n         setLastHit(randomRow, randomCol);\n         addPotentialTargets(_getAdjacentCells(randomRow, randomCol));\n      }\n   }\n};\n\nconst handleTargetMode = (cpuPlayer, opponent) => {\n   const {\n      getNextTarget,\n      getLastHit,\n      setShipOrientation,\n      getShipOrientation,\n      hasCellBeenAttacked,\n      markCellAsAttacked,\n   } = cpuPlayer;\n\n   let nextTarget;\n   do {\n      nextTarget = getNextTarget();\n   } while (nextTarget !== null && hasCellBeenAttacked(nextTarget.row, nextTarget.col));\n\n   if (nextTarget !== null) {\n      const { row: nextRow, col: nextCol } = nextTarget;\n      const result = runGame(nextRow, nextCol);\n      markCellAsAttacked(nextRow, nextCol);\n\n      if (result === \"H\") {\n         const shipToCheck = opponent.ownBoard.getShipIndex(nextRow, nextCol);\n         if (shipToCheck && shipToCheck.isSunk()) {\n            console.log(`Ship at (${nextRow}, ${nextCol}) is sunk! Resetting to hunt mode...`);\n            resetComputerPlayer(cpuPlayer);\n         } else {\n            if (getShipOrientation() === null) {\n               const { row: lastRow, col: lastCol } = getLastHit();\n               if (nextRow === lastRow) {\n                  setShipOrientation(\"horizontal\");\n               } else if (nextCol === lastCol) {\n                  setShipOrientation(\"vertical\");\n               }\n               console.log(`Detected ship orientation: ${getShipOrientation()}.`);\n            }\n            addTargetsAlongOrientation(cpuPlayer, nextRow, nextCol);\n         }\n      } else if (result === \"X\") {\n         console.log(\"That's a miss! Waiting for the next computer player turn...\");\n      }\n   } else {\n      console.log(\"No more valid targets! Resetting to hunt mode...\");\n      resetComputerPlayer(cpuPlayer);\n   }\n};\n\nexport const handleCpuTurn = (cpuPlayer) => {\n   const currentPlayer = takeTurns.getCurrentPlayer();\n   const opponent = currentPlayer === player1 ? player2 : player1;\n   const { getState } = cpuPlayer;\n\n   if (getState() === \"hunt\") {\n      handleHuntMode(cpuPlayer, opponent);\n   } else if (getState() === \"target\") {\n      handleTargetMode(cpuPlayer, opponent);\n   }\n};\n\n/* REFACTORING handleCpuTurn ENDS */\n\nconst _getAdjacentCells = (row, col) => {\n   return [\n      { row: row - 1, col }, // Up\n      { row: row + 1, col }, // Down\n      { row, col: col - 1 }, // Left\n      { row, col: col + 1 }, // Right\n   ].filter(({ row, col }) => row >= 0 && row < 10 && col >= 0 && col < 10); // Filter out-of-bounds cells\n};\n\nfunction _randomizeCoords() {\n   const randomRow = Math.floor(Math.random() * 10);\n   const randomCol = Math.floor(Math.random() * 10);\n   return { randomRow, randomCol };\n}\nfunction _checkIfCellWasAttacked(row, col, player) {\n   if (player.ownBoard.getCell(row, col) === \"X\" || player.ownBoard.getCell(row, col) === \"H\") {\n      return true;\n   }\n   return false;\n}\n\nexport const runGame = (row, col) => {\n   const currentPlayer = takeTurns.getCurrentPlayer();\n   const opponent = currentPlayer === player1 ? player2 : player1;\n   const result = opponent.ownBoard.receiveAttack(row, col);\n\n   passCellDisplayInfo(row, col, opponent.name, result);\n\n   if (opponent.ownBoard.isAllShipsSunken()) gameOver();\n\n   takeTurns.swapTurns();\n   const nextTurn = takeTurns.getCurrentPlayer();\n   passTurnInfo(nextTurn);\n\n   if (nextTurn === player2) {\n      setTimeout(() => {\n         handleCpuTurn(cpuPlayer);\n      }, 50);\n   }\n   return result;\n};\n\nconst takeTurns = (() => {\n   let currentPlayer = player1;\n\n   const swapTurns = () => (currentPlayer = currentPlayer === player1 ? player2 : player1);\n   const getCurrentPlayer = () => currentPlayer;\n   const isPlayerTurn = (player) => player === currentPlayer;\n\n   return {\n      swapTurns,\n      getCurrentPlayer,\n      isPlayerTurn,\n   };\n})();\n","export const ComputerPlayer = () => {\n   let state = \"hunt\";\n   let lastHit = null;\n   let potentialTargets = [];\n   const attackedCells = new Set();\n   let shipOrientation = null;\n\n   const getState = () => state;\n   const setState = (newState) => (state = newState);\n   const getLastHit = () => lastHit;\n   const setLastHit = (coords) => (lastHit = coords);\n   const addPotentialTargets = (targets) => potentialTargets.push(...targets);\n   const clearPotentialTargets = () => (potentialTargets = []);\n   const getNextTarget = () => (potentialTargets.length > 0 ? potentialTargets.shift() : null);\n   const getPotentialTargets = () => [...potentialTargets];\n   const markCellAsAttacked = (row, col) => attackedCells.add(`${row}, ${col}`);\n   const hasCellBeenAttacked = (row, col) => attackedCells.has(`${row}, ${col}`);\n   const getShipOrientation = () => shipOrientation;\n   const setShipOrientation = (orientatio) => (shipOrientation = orientatio);\n\n   return {\n      getState,\n      setState,\n      getLastHit,\n      setLastHit,\n      addPotentialTargets,\n      getNextTarget,\n      clearPotentialTargets,\n      getPotentialTargets,\n      markCellAsAttacked,\n      hasCellBeenAttacked,\n      getShipOrientation,\n      setShipOrientation,\n   };\n};\n","import { handleCellClick } from \"./AppController\";\n\nexport const renderGameBoards = (player1, player2) => {\n   const container = document.createElement(\"div\");\n   container.classList.add(\"container\");\n\n   const player1GameboardDOM = _createGameBoardDOM(player1, handleCellClick);\n   const player2GameboardDOM = _createGameBoardDOM(player2, handleCellClick);\n   container.append(player1GameboardDOM, player2GameboardDOM);\n\n   document.getElementById(\"root\").appendChild(container);\n};\n\nexport const updateCellContent = (row, col, playerName, isOccupied) => {\n   const cell = _getCellElement(row, col, playerName);\n   if (isOccupied === \"H\") {\n      cell.classList.remove(\"ship\");\n      cell.classList.add(\"hit\");\n   } else if (isOccupied === \"X\") {\n      cell.classList.add(\"miss\");\n   }\n   cell.classList.add(\"disabled\");\n};\n\nexport const updateDomOnTurn = (turnInfo) => {\n   const player1Board = document.querySelector(\"#player-1\");\n   const player2Board = document.querySelector(\"#player-2\");\n\n   if (turnInfo.name === \"player-1\") {\n      player1Board.classList.add(\"disabled\");\n      player2Board.classList.remove(\"disabled\");\n   } else if (turnInfo.name === \"player-2\") {\n      player2Board.classList.add(\"disabled\");\n      player1Board.classList.remove(\"disabled\");\n   }\n};\n\nexport const updateGameOver = () => {\n   _displayGameOver();\n};\n\nconst _getCellElement = (row, col, playerName) => {\n   const gameboard = document.getElementById(playerName);\n   return gameboard.querySelector(`[data-row=\"${row}\"][data-col=\"${col}\"]`);\n};\n\nconst _displayGameOver = () => {\n   const overlay = document.createElement(\"div\");\n   overlay.classList.add(\"overlay\");\n\n   const announcementCard = document.createElement(\"div\");\n   announcementCard.classList.add(\"announcement-card\");\n\n   const announcement = document.createElement(\"h2\");\n   announcement.textContent = \"Game Over\";\n\n   const closeButton = document.createElement(\"button\");\n   closeButton.textContent = \"Close\";\n   closeButton.addEventListener(\"click\", () => {\n      document.getElementById(\"root\").removeChild(overlay);\n   });\n\n   announcementCard.appendChild(announcement);\n   announcementCard.appendChild(closeButton);\n   overlay.appendChild(announcementCard);\n   document.getElementById(\"root\").appendChild(overlay);\n};\n\nconst _createGameBoardDOM = (player, callback) => {\n   const size = player.ownBoard.getGrid().length;\n   const playerName = player.name;\n   const gridContainer = document.createElement(\"div\");\n   gridContainer.classList.add(\"game-board\");\n   gridContainer.id = playerName;\n\n   for (let col = 0; col < size; col++) {\n      const colElement = document.createElement(\"div\");\n      colElement.classList.add(\"column\");\n\n      for (let row = 0; row < size; row++) {\n         const cell = document.createElement(\"div\");\n         cell.classList.add(\"cell\");\n         cell.dataset.row = row;\n         cell.dataset.col = col;\n         const isOccupied = player.ownBoard.hasShip(row, col);\n         if (player.name !== \"player-2\" && isOccupied) {\n            cell.classList.add(\"ship\");\n         }\n         cell.addEventListener(\"click\", () => callback(row, col, player));\n         colElement.appendChild(cell);\n      }\n      gridContainer.appendChild(colElement);\n   }\n\n   return gridContainer;\n};\n","import { player1, player2, runGame } from \"./GameController\";\nimport {\n   renderGameBoards,\n   updateCellContent,\n   updateGameOver,\n   updateDomOnTurn,\n} from \"./DomController\";\n\nexport const initApp = () => {\n   renderGameBoards(player1, player2);\n};\n\nexport const handleCellClick = (row, col) => {\n   row = Number(row);\n   col = Number(col);\n   runGame(row, col);\n};\n\nexport const passCellDisplayInfo = (row, col, player, isOccupied) =>\n   updateCellContent(row, col, player, isOccupied);\n\nexport const gameOver = () => {\n   updateGameOver();\n};\n\nexport const passTurnInfo = (turnInfo) => updateDomOnTurn(turnInfo);\n"],"names":["Gameboard","size","board","Array","from","length","fill","ships","getCell","row","col","hasShip","getShip","index","Number","isInteger","undefined","placeShip","direction","i","_isValidPlacement","Error","ship","startRow","startCol","hits","getHits","hit","isSunk","Ship","shipIndex","push","newCol","getAllShips","receiveAttack","cell","console","log","isAllShipsSunken","every","getGrid","getShipPositions","map","getShipIndex","find","Player","name","ownBoard","cpuPlayer","state","lastHit","potentialTargets","attackedCells","Set","shipOrientation","getState","setState","newState","getLastHit","setLastHit","coords","addPotentialTargets","targets","getNextTarget","shift","clearPotentialTargets","getPotentialTargets","markCellAsAttacked","add","hasCellBeenAttacked","has","getShipOrientation","setShipOrientation","orientatio","ComputerPlayer","player1","player2","resetComputerPlayer","_getAdjacentCells","filter","runGame","opponent","takeTurns","getCurrentPlayer","result","passCellDisplayInfo","gameOver","swapTurns","nextTurn","passTurnInfo","setTimeout","randomRow","randomCol","Math","floor","random","shipToCheck","handleHuntMode","nextTarget","nextRow","nextCol","lastRow","lastCol","forEach","addTargetsAlongOrientation","handleTargetMode","handleCpuTurn","currentPlayer","isPlayerTurn","player","_createGameBoardDOM","callback","playerName","gridContainer","document","createElement","classList","id","colElement","dataset","isOccupied","addEventListener","appendChild","handleCellClick","getElementById","querySelector","_getCellElement","remove","updateCellContent","overlay","announcementCard","announcement","textContent","closeButton","removeChild","_displayGameOver","turnInfo","player1Board","player2Board","updateDomOnTurn","container","player1GameboardDOM","player2GameboardDOM","append","renderGameBoards"],"sourceRoot":""}