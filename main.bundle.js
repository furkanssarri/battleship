(()=>{"use strict";const t=t=>{const e=Array.from({length:t},(()=>Array(t).fill(null))),o=[],a=(t,o)=>e[t][o],n=(t,e)=>null!==a(t,e),l=(t,a)=>{const n=e[t][a];return Number.isInteger(n)?o[n]:void 0};return{placeShip:(a,l,r,s)=>{if(!((e,o,a,l)=>{if("horizontal"===l&&o+a>t)return!1;if("vertical"===l&&e+a>t)return!1;for(let t=0;t<a;t++)if(n("vertical"===l?e+t:e,"horizontal"===l?o+t:o))return!1;return!0})(a,l,r,s))throw new Error("Invalid placement: Out of bounds or overlapping.");const i=((t,e,o,a)=>{let n=0;return{length:t,direction:e,startRow:o,startCol:a,getHits:()=>n,hit:()=>{++n},isSunk:()=>n>=t}})(r,s,a,l),c=o.length;o.push(i);for(let t=0;t<r;t++){const o="horizontal"===s?l+t:l;e["vertical"===s?a+t:a][o]=c}},getCell:a,hasShip:n,getShip:l,getAllShips:()=>[...o],receiveAttack:(t,o)=>{const n=a(t,o);if(null===n)return e[t][o]="X","X";if(Number.isInteger(n)){const a=l(t,o);if(a)return a.hit(),e[t][o]="H","H"}return console.log("Cell already attacked... Skipping..."),"Cell already attacked... Skipping..."},isAllShipsSunken:()=>o.every((t=>t.isSunk())),getGrid:()=>e,getShipPositions:()=>o.map((({startRow:t,startCol:e,length:o,direction:a})=>({startRow:t,startCol:e,length:o,direction:a}))),getShipIndex:(t,e)=>o.find((o=>{const{startRow:a,startCol:n,length:l,direction:r}=o;return"horizontal"===r?t===a&&e>=n&&e<n+l:e===n&&t>=a&&t<a+l}))||void 0}},e=e=>({name:e,ownBoard:t(10)}),o=(()=>{let t="hunt",e=null,o=[];return{getState:()=>t,setState:e=>t=e,setLastHit:t=>e=t,addPotentialTargets:t=>o.push(...t),getNextTarget:()=>o.shift(),clearPotentialTargets:()=>o=[],getPotentialTargets:()=>[...o]}})(),a=e("player-1");a.ownBoard.placeShip(4,3,5,"horizontal"),a.ownBoard.placeShip(6,4,4,"vertical"),a.ownBoard.placeShip(2,1,3,"horizontal"),a.ownBoard.placeShip(1,8,2,"vertical"),a.ownBoard.placeShip(0,4,3,"horizontal"),a.ownBoard.placeShip(8,6,3,"horizontal");const n=e("player-2");n.ownBoard.placeShip(0,1,5,"horizontal"),n.ownBoard.placeShip(3,2,4,"vertical"),n.ownBoard.placeShip(7,5,3,"vertical"),n.ownBoard.placeShip(5,5,3,"horizontal"),n.ownBoard.placeShip(2,6,2,"horizontal"),n.ownBoard.placeShip(2,4,2,"vertical");const l=(t,e)=>[{row:t-1,col:e},{row:t+1,col:e},{row:t,col:e-1},{row:t,col:e+1}].filter((({row:t,col:e})=>t>=0&&t<10&&e>=0&&e<10));function r(t,e,o){return"X"===o.ownBoard.getCell(t,e)||"H"===o.ownBoard.getCell(t,e)}const s=(t,e)=>{const c=i.getCurrentPlayer()===a?n:a,d=c.ownBoard.receiveAttack(t,e);h(t,e,c.name,d),c.ownBoard.isAllShipsSunken()&&u(),i.swapTurns();const p=i.getCurrentPlayer();return g(p),p===n&&setTimeout((()=>{(t=>{const{getState:e,setState:o,setLastHit:n,addPotentialTargets:i,getNextTarget:c,getPotentialTargets:d,clearPotentialTargets:h}=t;let u,g;if("hunt"===e()){do{({randomRow:u,randomCol:g}={randomRow:Math.floor(10*Math.random()),randomCol:Math.floor(10*Math.random())})}while(r(u,g,a));console.log(`attacking ${u}, ${g} with ${e()} status...`),"H"===s(u,g)&&(o("target"),console.log(`the status has changed to ${e()}.`),n(u,g),console.log(`saving the last successful hit's coords ${u}, ${g}...`),i(l(u,g)),console.log(`calculating the adjacent cells to the last hit, which was at coords: ${u}, ${g}...`),console.log("the potential targets are: ",d()),console.log(`and the status is: ${e()}`))}else if("target"===e()){console.log(`attacking with updated status of: ${e()}`),console.log("getting the new coords for the next attack...");const t=c(),a=t.row,r=t.col;if(console.log("undestructed new coords: ",t),console.log(`the new coords to attack is: ${a}, ${r}.`),a&&r){console.log(`attacking the new coords ${a}, ${r} with the status of ${e()}...`);const t=s(a,r);"H"===t?(console.log(`HIT AGAIN! adding the coords ${a}, ${r} to the adjacent cells...`),i(l(a,r)),console.log(`the updated version of adjacent cells are: ${i(l(a,r))}.`)):"X"===t&&console.log("thats a miss! waiting for next Computer player turn...")}else console.log(`The ship's sunk! resetting the status of ${e()}...`),o("hunt"),n(null),console.log(`resetting has been done. now we are back to the status of ${e()}, and the last hit was reset bacj to null.`),h(),console.log(`cleared potential targets list: ${d()}.`)}})(o)}),50),d},i=(()=>{let t=a;return{swapTurns:()=>t=t===a?n:a,getCurrentPlayer:()=>t,isPlayerTurn:e=>e===t}})(),c=(t,e)=>{const o=t.ownBoard.getGrid().length,a=t.name,n=document.createElement("div");n.classList.add("game-board"),n.id=a;for(let a=0;a<o;a++){const l=document.createElement("div");l.classList.add("column");for(let n=0;n<o;n++){const o=document.createElement("div");o.classList.add("cell"),o.dataset.row=n,o.dataset.col=a;const r=t.ownBoard.hasShip(n,a);"player-2"!==t.name&&r&&o.classList.add("ship"),o.addEventListener("click",(()=>e(n,a,t))),l.appendChild(o)}n.appendChild(l)}return n},d=(t,e)=>{t=Number(t),e=Number(e),s(t,e)},h=(t,e,o,a)=>((t,e,o,a)=>{const n=((t,e,o)=>document.getElementById(o).querySelector(`[data-row="${t}"][data-col="${e}"]`))(t,e,o);"H"===a?(n.classList.remove("ship"),n.classList.add("hit")):"X"===a&&n.classList.add("miss"),n.classList.add("disabled")})(t,e,o,a),u=()=>{(()=>{const t=document.createElement("div");t.classList.add("overlay");const e=document.createElement("div");e.classList.add("announcement-card");const o=document.createElement("h2");o.textContent="Game Over";const a=document.createElement("button");a.textContent="Close",a.addEventListener("click",(()=>{document.getElementById("root").removeChild(t)})),e.appendChild(o),e.appendChild(a),t.appendChild(e),document.getElementById("root").appendChild(t)})()},g=t=>(t=>{const e=document.querySelector("#player-1"),o=document.querySelector("#player-2");"player-1"===t.name?(e.classList.add("disabled"),o.classList.remove("disabled")):"player-2"===t.name&&(o.classList.add("disabled"),e.classList.remove("disabled"))})(t);((t,e)=>{const o=document.createElement("div");o.classList.add("container");const a=c(t,d),n=c(e,d);o.append(a,n),document.getElementById("root").appendChild(o)})(a,n)})();
//# sourceMappingURL=main.bundle.js.map