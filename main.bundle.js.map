{"version":3,"file":"main.bundle.js","mappings":"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","sources":["webpack://battleship/./src/components/Ship.js","webpack://battleship/./src/components/Gameboard.js","webpack://battleship/./src/components/Player.js","webpack://battleship/./src/ShipPlacer.js","webpack://battleship/./src/GameController.js","webpack://battleship/./src/components/ComputerPlayer.js","webpack://battleship/./src/DomController.js","webpack://battleship/./src/AppController.js"],"sourcesContent":["export const Ship = (length, direction, startRow, startCol) => {\n   let hits = 0;\n\n   const getHits = () => hits;\n   const hit = () => {\n      ++hits;\n   };\n   const isSunk = () => hits >= length;\n   return {\n      length,\n      direction,\n      startRow,\n      startCol,\n      getHits,\n      hit,\n      isSunk,\n   };\n};\n","import { Ship } from \"./Ship\";\n\nexport const Gameboard = (size) => {\n   const board = Array.from({ length: size }, () => Array(size).fill(null));\n   const ships = [];\n\n   const getCell = (row, col) => board[row][col];\n   const hasShip = (row, col) => getCell(row, col) !== null;\n   const getAllShips = () => [...ships];\n   const isAllShipsSunken = () => ships.every((ship) => ship.isSunk());\n   const getGrid = () => board;\n\n   const getShipPositions = () =>\n      ships.map(({ startRow, startCol, length, direction }) => ({\n         startRow,\n         startCol,\n         length,\n         direction,\n      }));\n\n   const getShipIndex = (row, col) => {\n      return (\n         ships.find((ship) => {\n            const { startRow, startCol, length, direction } = ship;\n            if (direction === \"horizontal\") {\n               return row === startRow && col >= startCol && col < startCol + length;\n            } else {\n               return col === startCol && row >= startRow && row < startRow + length;\n            }\n         }) || undefined\n      );\n   };\n\n   const getShip = (row, col) => {\n      const index = board[row][col];\n      return Number.isInteger(index) ? ships[index] : undefined;\n   };\n\n   const _isValidPlacement = (row, col, length, direction) => {\n      if (direction === \"horizontal\" && col + length > size) return false;\n      if (direction === \"vertical\" && row + length > size) return false;\n\n      for (let i = 0; i < length; i++) {\n         const newRow = direction === \"vertical\" ? row + i : row;\n         const newCol = direction === \"horizontal\" ? col + i : col;\n         if (hasShip(newRow, newCol)) return false;\n      }\n      return true;\n   };\n\n   const placeShip = (row, col, length, direction) => {\n      if (!_isValidPlacement(row, col, length, direction)) {\n         throw new Error(\"Invalid placement: Out of bounds or overlapping.\");\n      }\n\n      const ship = Ship(length, direction, row, col);\n      const shipIndex = ships.length;\n      ships.push(ship);\n\n      for (let i = 0; i < length; i++) {\n         const newRow = direction === \"vertical\" ? row + i : row;\n         const newCol = direction === \"horizontal\" ? col + i : col;\n         board[newRow][newCol] = shipIndex;\n      }\n   };\n\n   const receiveAttack = (row, col) => {\n      let cell = getCell(row, col);\n      if (cell === null) {\n         board[row][col] = \"X\"; // Missed shot\n         return \"X\";\n      }\n      if (Number.isInteger(cell)) {\n         const ship = getShip(row, col);\n         if (ship) {\n            ship.hit();\n            board[row][col] = \"H\";\n            return \"H\";\n         }\n      }\n      // throw new Error(\"This cell was already attacked.\");\n      console.log(\"Cell already attacked... Skipping...\");\n      return \"Cell already attacked... Skipping...\";\n   };\n\n   return {\n      placeShip,\n      getCell,\n      hasShip,\n      getShip,\n      getAllShips,\n      receiveAttack,\n      isAllShipsSunken,\n      getGrid,\n      getShipPositions,\n      getShipIndex,\n   };\n};\n","import { Gameboard } from \"./Gameboard\";\n\nexport const Player = (name) => {\n   const ownBoard = Gameboard(10);\n\n   return {\n      name,\n      ownBoard,\n   };\n};\n","export const ShipPlacer = (player) => {\n   const size = player.ownBoard.getGrid().length;\n   const placeShipManually = (row, col, length, direction) => {\n      try {\n         player.ownBoard.placeShip(row, col, length, direction);\n         return true;\n      } catch (error) {\n         console.log(error.message);\n         return false;\n      }\n   };\n\n   const placeShipsRandomly = (armada) => {\n      const maxAttempts = 100; // Maximum number of attempts to place a ship\n      armada.forEach((vessel) => {\n         let placed = false;\n         let attempts = 0;\n\n         while (!placed && attempts < maxAttempts) {\n            const randomDirection = Math.random() < 0.5 ? \"horizontal\" : \"vertical\";\n            const randomRow = Math.floor(Math.random() * size); // Random row within board size\n            const randomCol = Math.floor(Math.random() * size); // Random column within board size\n\n            try {\n               player.ownBoard.placeShip(randomRow, randomCol, vessel.ship.length, randomDirection);\n               placed = true; // Mark as placed if successful\n            } catch (error) {\n               attempts++; // Increment attempt counter\n               if (attempts >= maxAttempts) {\n                  console.log(\n                     `Failed to place ${vessel.type} after ${maxAttempts} attempts. Skipping...`,\n                  );\n               }\n            }\n         }\n      });\n   };\n\n   return {\n      placeShipManually,\n      placeShipsRandomly,\n   };\n};\n","import { Player } from \"./components/Player\";\nimport { ComputerPlayer } from \"./components/ComputerPlayer\";\nimport {\n   gameOver,\n   passCellDisplayInfo,\n   passTurnInfo,\n   callUpdateGameboardDOM,\n   updatePlacementUI,\n   passGridContainer,\n   callAddHighlight,\n   callRemoveHighlights,\n} from \"./AppController\";\nimport { ShipPlacer } from \"./ShipPlacer\";\nimport { Ship } from \"./components/Ship\";\n\nconst cpuPlayer = ComputerPlayer();\nexport const player1 = Player(\"player-1\");\n\nexport const player2 = Player(\"player-2\");\n\nexport const vesselOrientation = (() => {\n   let vesselOrientation = \"horizontal\";\n\n   const getVesselOrientation = () => vesselOrientation;\n   const setVesselOrientation = (orientation) => (vesselOrientation = orientation);\n   const swapVesselOrientation = () =>\n      (vesselOrientation = vesselOrientation === \"horizontal\" ? \"vertical\" : \"horizontal\");\n\n   return { getVesselOrientation, setVesselOrientation, swapVesselOrientation };\n})();\n\nlet currentShipIndex = 0;\nconst armada = [\n   { type: \"Battleship\", ship: Ship(5) },\n   { type: \"Destroyer\", ship: Ship(4) },\n   { type: \"Submarine\", ship: Ship(4) },\n   { type: \"Carrier\", ship: Ship(3) },\n   { type: \"Boat\", ship: Ship(2) },\n];\n\nexport const placeShips = (row, col) => {\n   let theShipOrientation = vesselOrientation.getVesselOrientation();\n   const shipPlacer = ShipPlacer(player1);\n\n   if (currentShipIndex < armada.length) {\n      const vessel = armada[currentShipIndex];\n      const placementSuccessful = shipPlacer.placeShipManually(\n         row,\n         col,\n         vessel.ship.length,\n         theShipOrientation,\n      );\n\n      if (placementSuccessful) {\n         callUpdateGameboardDOM(player1);\n         currentShipIndex++;\n      }\n   }\n\n   if (currentShipIndex === armada.length) {\n      updatePlacementUI();\n   }\n};\n\nexport const highlightShipPlacement = (row, col, player) => {\n   const gridContainer = passGridContainer();\n   const shipLength = armada[currentShipIndex]?.ship.length || 0;\n   const orientation = vesselOrientation.getVesselOrientation();\n\n   callRemoveHighlights(gridContainer); // Clear previous highlights\n\n   if (shipLength === 0) return;\n\n   for (let i = 0; i < shipLength; i++) {\n      let targetRow = row;\n      let targetCol = col;\n\n      if (orientation === \"horizontal\") {\n         targetCol = col + i;\n      } else if (orientation === \"vertical\") {\n         targetRow = row + i;\n      }\n\n      if (\n         targetRow < player.ownBoard.getGrid().length &&\n         targetCol < player.ownBoard.getGrid().length\n      ) {\n         const cell = gridContainer.querySelector(\n            `.cell[data-row=\"${targetRow}\"][data-col=\"${targetCol}\"]`,\n         );\n         if (cell) {\n            callAddHighlight(cell);\n         }\n      }\n   }\n};\n\nexport const randomlyPlaceCpuPlayerShips = () => {\n   const randomShipPlacer = ShipPlacer(player2);\n   randomShipPlacer.placeShipsRandomly(armada);\n};\n\nexport const resetComputerPlayer = (cpuPlayer) => {\n   const { setState, setLastHit, setShipOrientation, clearPotentialTargets } = cpuPlayer;\n   setState(\"hunt\");\n   setLastHit(null);\n   setShipOrientation(null);\n   clearPotentialTargets();\n};\n\nexport const addTargetsAlongOrientation = (cpuPlayer, row, col) => {\n   const { addPotentialTargets, getShipOrientation, hasCellBeenAttacked } = cpuPlayer;\n\n   if (getShipOrientation() === \"horizontal\") {\n      // Add all valid cells to the left, skipping already-attacked cells\n      let leftCol = col - 1;\n      while (leftCol >= 0 && !hasCellBeenAttacked(row, leftCol)) {\n         addPotentialTargets([{ row, col: leftCol }]);\n         leftCol--;\n      }\n\n      // Add all valid cells to the right, skipping already-attacked cells\n      let rightCol = col + 1;\n      while (rightCol < 10 && !hasCellBeenAttacked(row, rightCol)) {\n         addPotentialTargets([{ row, col: rightCol }]);\n         rightCol++;\n      }\n   } else if (getShipOrientation() === \"vertical\") {\n      // Add all valid cells above, skipping already-attacked cells\n      let upRow = row - 1;\n      while (upRow >= 0 && !hasCellBeenAttacked(upRow, col)) {\n         addPotentialTargets([{ row: upRow, col }]);\n         upRow--;\n      }\n\n      // Add all valid cells below, skipping already-attacked cells\n      let downRow = row + 1;\n      while (downRow < 10 && !hasCellBeenAttacked(downRow, col)) {\n         addPotentialTargets([{ row: downRow, col }]);\n         downRow++;\n      }\n   }\n};\n\nexport const handleHuntMode = (cpuPlayer, opponent) => {\n   const {\n      setState,\n      setLastHit,\n      getLastHit,\n      addPotentialTargets,\n      hasCellBeenAttacked,\n      markCellAsAttacked,\n   } = cpuPlayer;\n\n   let randomRow, randomCol;\n   do {\n      ({ randomRow, randomCol } = _randomizeCoords());\n   } while (hasCellBeenAttacked(randomRow, randomCol));\n\n   const result = runGame(randomRow, randomCol);\n   markCellAsAttacked(randomRow, randomCol);\n\n   if (result === \"H\") {\n      const shipToCheck = opponent.ownBoard.getShipIndex(randomRow, randomCol);\n      if (shipToCheck && shipToCheck.isSunk()) {\n         resetComputerPlayer(cpuPlayer);\n      } else {\n         setState(\"target\");\n         setLastHit({ row: randomRow, col: randomCol });\n         addPotentialTargets(_getAdjacentCells(randomRow, randomCol));\n      }\n   }\n};\n\nexport const handleTargetMode = (cpuPlayer, opponent) => {\n   const {\n      getNextTarget,\n      getLastHit,\n      setShipOrientation,\n      getShipOrientation,\n      hasCellBeenAttacked,\n      markCellAsAttacked,\n      getAttackDirection,\n      setAttackDirection,\n      getCurrentShipLength,\n      setCurrentShipLength,\n      resetCurrentShipLength,\n   } = cpuPlayer;\n\n   let nextTarget;\n   do {\n      nextTarget = getNextTarget();\n   } while (nextTarget !== null && hasCellBeenAttacked(nextTarget.row, nextTarget.col));\n\n   if (nextTarget !== null) {\n      const { row: nextRow, col: nextCol } = nextTarget;\n      const result = runGame(nextRow, nextCol);\n      markCellAsAttacked(nextRow, nextCol);\n\n      if (result === \"H\") {\n         const shipToCheck = opponent.ownBoard.getShipIndex(nextRow, nextCol);\n         if (shipToCheck && shipToCheck.isSunk()) {\n            resetComputerPlayer(cpuPlayer);\n            resetCurrentShipLength();\n         } else {\n            if (getShipOrientation() === null) {\n               const { row: lastRow, col: lastCol } = getLastHit();\n\n               if (nextRow === lastRow) {\n                  setShipOrientation(\"horizontal\");\n               } else if (nextCol === lastCol) {\n                  setShipOrientation(\"vertical\");\n               }\n            }\n\n            // Increment the current ship length\n            setCurrentShipLength(getCurrentShipLength() + 1);\n\n            // Add all valid targets along the ship's orientation\n            addTargetsAlongOrientation(cpuPlayer, nextRow, nextCol);\n         }\n      } else if (result === \"X\") {\n         const currentDirection = getAttackDirection();\n         const newDirection =\n            currentDirection === \"right\"\n               ? \"left\"\n               : currentDirection === \"left\"\n                 ? \"right\"\n                 : currentDirection === \"up\"\n                   ? \"down\"\n                   : \"up\";\n         setAttackDirection(newDirection);\n         addTargetsAlongOrientation(cpuPlayer, nextRow, nextCol);\n      }\n   } else {\n      resetComputerPlayer(cpuPlayer);\n      resetCurrentShipLength();\n   }\n};\n\nexport const handleCpuTurn = (cpuPlayer) => {\n   const currentPlayer = takeTurns.getCurrentPlayer();\n   const opponent = currentPlayer === player1 ? player2 : player1;\n   const { getState } = cpuPlayer;\n\n   if (getState() === \"hunt\") {\n      handleHuntMode(cpuPlayer, opponent);\n   } else if (getState() === \"target\") {\n      handleTargetMode(cpuPlayer, opponent);\n   }\n};\n\nconst _getAdjacentCells = (row, col) => {\n   return [\n      { row: row - 1, col }, // Up\n      { row: row + 1, col }, // Down\n      { row, col: col - 1 }, // Left\n      { row, col: col + 1 }, // Right\n   ].filter(({ row, col }) => row >= 0 && row < 10 && col >= 0 && col < 10); // Filter out-of-bounds cells\n};\n\nconst _randomizeCoords = () => {\n   const randomRow = Math.floor(Math.random() * 10);\n   const randomCol = Math.floor(Math.random() * 10);\n   return { randomRow, randomCol };\n};\nconst _checkIfCellWasAttacked = (row, col, player) => {\n   if (player.ownBoard.getCell(row, col) === \"X\" || player.ownBoard.getCell(row, col) === \"H\") {\n      return true;\n   }\n   return false;\n};\n\nexport const runGame = (row, col) => {\n   const currentPlayer = takeTurns.getCurrentPlayer();\n   const opponent = currentPlayer === player1 ? player2 : player1;\n   const result = opponent.ownBoard.receiveAttack(row, col);\n\n   passCellDisplayInfo(row, col, opponent.name, result);\n\n   if (opponent.ownBoard.isAllShipsSunken()) gameOver();\n\n   takeTurns.swapTurns();\n   const nextTurn = takeTurns.getCurrentPlayer();\n   passTurnInfo(nextTurn);\n\n   if (nextTurn === player2) {\n      setTimeout(() => {\n         handleCpuTurn(cpuPlayer);\n      }, 50);\n   }\n   return result;\n};\n\nconst takeTurns = (() => {\n   let currentPlayer = player1;\n\n   const swapTurns = () => (currentPlayer = currentPlayer === player1 ? player2 : player1);\n   const getCurrentPlayer = () => currentPlayer;\n   const isPlayerTurn = (player) => player === currentPlayer;\n\n   return {\n      swapTurns,\n      getCurrentPlayer,\n      isPlayerTurn,\n   };\n})();\n","export const ComputerPlayer = () => {\n   let state = \"hunt\";\n   let lastHit = null; // Stores the last hit coordinates as { row, col }\n   let potentialTargets = [];\n   const attackedCells = new Set();\n   let shipOrientation = null;\n   let attackDirection = null; // \"left\", \"right\", \"up\", or \"down\"\n   let currentShipLength = 0; // Track the length of the current ship\n\n   const getState = () => state;\n   const setState = (newState) => (state = newState);\n   const getLastHit = () => lastHit;\n   const setLastHit = (coords) => (lastHit = coords);\n   const addPotentialTargets = (targets) => potentialTargets.push(...targets);\n   const clearPotentialTargets = () => (potentialTargets = []);\n   const getNextTarget = () => (potentialTargets.length > 0 ? potentialTargets.shift() : null);\n   const getPotentialTargets = () => [...potentialTargets];\n   const markCellAsAttacked = (row, col) => attackedCells.add(`${row}, ${col}`);\n   const hasCellBeenAttacked = (row, col) => attackedCells.has(`${row}, ${col}`);\n   const getShipOrientation = () => shipOrientation;\n   const setShipOrientation = (orientation) => (shipOrientation = orientation);\n   const getAttackDirection = () => attackDirection;\n   const setAttackDirection = (direction) => (attackDirection = direction);\n   const getCurrentShipLength = () => currentShipLength;\n   const setCurrentShipLength = (length) => (currentShipLength = length);\n   const resetCurrentShipLength = () => (currentShipLength = 0);\n\n   return {\n      getState,\n      setState,\n      getLastHit,\n      setLastHit,\n      addPotentialTargets,\n      getNextTarget,\n      clearPotentialTargets,\n      getPotentialTargets,\n      markCellAsAttacked,\n      hasCellBeenAttacked,\n      getShipOrientation,\n      setShipOrientation,\n      getAttackDirection,\n      setAttackDirection,\n      getCurrentShipLength,\n      setCurrentShipLength,\n      resetCurrentShipLength,\n   };\n};\n","import {\n   handleCellClick,\n   handleShipClick,\n   callHighlightShipPlacement,\n   isTouchDevice,\n} from \"./AppController\";\n\nexport const renderGameBoards = (player1, player2) => {\n   const container = document.createElement(\"div\");\n   container.classList.add(\"container\");\n\n   const player1GameboardDOM = _createGameBoardDOM(player1, handleCellClick);\n   const player2GameboardDOM = _createGameBoardDOM(player2, handleCellClick);\n\n   container.append(player1GameboardDOM, player2GameboardDOM);\n   document.getElementById(\"root\").appendChild(container);\n};\n\nexport const renderShipPlacementBoard = (player) => {\n   const overlay = document.createElement(\"div\");\n   overlay.classList.add(\"overlay\");\n\n   const popup = document.createElement(\"div\");\n   popup.classList.add(\"place-ships\");\n\n   const messageHeading = document.createElement(\"h3\");\n   messageHeading.textContent = \"Place your ships\";\n\n   const messageBody = document.createElement(\"span\");\n   messageBody.classList.add(\"hint-span\");\n\n   messageBody.textContent = isTouchDevice()\n      ? \"Hint: You can right click to change your ship's orientation.\"\n      : \"Hint: You can press and hold to change your ship's orientation.\";\n   popup.append(messageHeading, messageBody);\n\n   const gameBoardDOM = _createGameBoardDOM(\n      player,\n      (row, col, player, clickType) => handleShipClick(row, col, player, clickType),\n      `${player.name}-popup`,\n   );\n   popup.appendChild(gameBoardDOM);\n\n   const closeBtn = document.createElement(\"button\");\n   closeBtn.textContent = \"Close\";\n   closeBtn.addEventListener(\"click\", () => {\n      document.getElementById(\"root\").removeChild(overlay);\n   });\n   popup.appendChild(closeBtn);\n\n   overlay.appendChild(popup);\n   document.getElementById(\"root\").appendChild(overlay);\n};\n\nexport const getGridContainer = () => {\n   return document.getElementById(\"player-1-popup\");\n};\n\nexport const addHighlight = (cell) => {\n   cell.classList.add(\"highlight\");\n};\n\nexport const removeHighlights = (gridContainer) => {\n   if (!gridContainer) return;\n\n   const highlightedCells = gridContainer.querySelectorAll(\".highlight\");\n   highlightedCells.forEach((cell) => {\n      cell.classList.remove(\"highlight\");\n   });\n};\n\nexport const UpdateGameboardDOM = (player) => {\n   const originalGameboardElement = document.getElementById(player.name);\n   const popupGameboardElement = document.getElementById(`${player.name}-popup`);\n   const size = player.ownBoard.getGrid().length;\n\n   const updateGameboardElement = (gameboardElement) => {\n      if (!gameboardElement) return;\n      for (let row = 0; row < size; row++) {\n         for (let col = 0; col < size; col++) {\n            const cell = gameboardElement.querySelector(`[data-row=\"${row}\"][data-col=\"${col}\"]`);\n            const isOccupied = player.ownBoard.hasShip(row, col);\n\n            if (player.name != \"player-2\" && isOccupied) {\n               cell.classList.add(\"ship\");\n            }\n         }\n      }\n   };\n\n   updateGameboardElement(originalGameboardElement);\n   updateGameboardElement(popupGameboardElement);\n};\n\nexport const updateCellContent = (row, col, playerName, isOccupied) => {\n   const cell = _getCellElement(row, col, playerName);\n   if (isOccupied === \"H\") {\n      cell.classList.remove(\"ship\");\n      cell.classList.add(\"hit\");\n   } else if (isOccupied === \"X\") {\n      cell.classList.add(\"miss\");\n   }\n   cell.classList.add(\"disabled\");\n};\n\nexport const updateDomOnTurn = (turnInfo) => {\n   const player1Board = document.querySelector(\"#player-1\");\n   const player2Board = document.querySelector(\"#player-2\");\n\n   if (turnInfo.name === \"player-1\") {\n      player1Board.classList.add(\"disabled\");\n      player2Board.classList.remove(\"disabled\");\n   } else if (turnInfo.name === \"player-2\") {\n      player2Board.classList.add(\"disabled\");\n      player1Board.classList.remove(\"disabled\");\n   }\n};\n\nexport const removePlacementOverlay = () => {\n   const overlay = document.querySelector(\".overlay\");\n   setTimeout(() => {\n      document.getElementById(\"root\").removeChild(overlay);\n   }, 1000);\n};\n\nexport const updateGameOver = () => {\n   _displayGameOver();\n};\n\nconst _getCellElement = (row, col, playerName) => {\n   const gameboard = document.getElementById(playerName);\n   return gameboard.querySelector(`[data-row=\"${row}\"][data-col=\"${col}\"]`);\n};\n\nconst _displayGameOver = () => {\n   const overlay = document.createElement(\"div\");\n   overlay.classList.add(\"overlay\");\n\n   const announcementCard = document.createElement(\"div\");\n   announcementCard.classList.add(\"announcement-card\");\n\n   const announcement = document.createElement(\"h2\");\n   announcement.textContent = \"Game Over\";\n\n   const closeButton = document.createElement(\"button\");\n   closeButton.textContent = \"Close\";\n   closeButton.addEventListener(\"click\", () => {\n      // document.getElementById(\"root\").removeChild(overlay);\n      location.reload();\n   });\n\n   announcementCard.appendChild(announcement);\n   announcementCard.appendChild(closeButton);\n   overlay.appendChild(announcementCard);\n   document.getElementById(\"root\").appendChild(overlay);\n};\n\nconst _createGameBoardDOM = (player, callback, customId = null) => {\n   const size = player.ownBoard.getGrid().length;\n   const playerName = customId || player.name;\n   const gridContainer = document.createElement(\"div\");\n   gridContainer.classList.add(\"game-board\");\n   gridContainer.id = playerName;\n\n   let longPressTimer = null;\n\n   for (let col = 0; col < size; col++) {\n      const colElement = document.createElement(\"div\");\n      colElement.classList.add(\"column\");\n\n      for (let row = 0; row < size; row++) {\n         const cell = document.createElement(\"div\");\n         cell.classList.add(\"cell\");\n         cell.dataset.row = row;\n         cell.dataset.col = col;\n         const isOccupied = player.ownBoard.hasShip(row, col);\n         if (player.name !== \"player-2\" && isOccupied) {\n            cell.classList.add(\"ship\");\n         }\n         cell.addEventListener(\"mousedown\", (event) => {\n            if (event.button === 0) {\n               callback(row, col, player, \"left\");\n            } else if (event.button === 2) {\n               callback(row, col, player, \"right\");\n            }\n         });\n\n         // Touch events for press-and-hold (simulate right click)\n         cell.addEventListener(\"touchstart\", (event) => {\n            // Prevent default behavior (e.g., scrolling)\n            event.preventDefault();\n\n            // Start a timer for long press\n            longPressTimer = setTimeout(() => {\n               callback(row, col, player, \"right\"); // Simulate right click\n               longPressTimer = null; // Reset the timer\n            }, 500); // 500ms delay for long press\n         });\n\n         cell.addEventListener(\"touchend\", (event) => {\n            // Clear the timer if the touch ends before the long press duration\n            if (longPressTimer) {\n               clearTimeout(longPressTimer);\n               longPressTimer = null;\n               callback(row, col, player, \"left\"); // Simulate left click\n            }\n         });\n\n         cell.addEventListener(\"touchmove\", (event) => {\n            // Clear the timer if the user moves their finger\n            if (longPressTimer) {\n               clearTimeout(longPressTimer);\n               longPressTimer = null;\n            }\n         });\n\n         cell.addEventListener(\"mouseover\", () => {\n            callHighlightShipPlacement(row, col, player);\n         });\n\n         cell.addEventListener(\"mouseleave\", () => {\n            removeHighlights(gridContainer);\n         });\n\n         cell.addEventListener(\"contextmenu\", (event) => {\n            event.preventDefault();\n         });\n\n         colElement.appendChild(cell);\n      }\n      gridContainer.appendChild(colElement);\n   }\n\n   return gridContainer;\n};\n","import {\n   player1,\n   player2,\n   runGame,\n   placeShips,\n   vesselOrientation,\n   randomlyPlaceCpuPlayerShips,\n   highlightShipPlacement,\n} from \"./GameController\";\nimport {\n   renderGameBoards,\n   renderShipPlacementBoard,\n   updateCellContent,\n   updateGameOver,\n   updateDomOnTurn,\n   UpdateGameboardDOM,\n   removePlacementOverlay,\n   getGridContainer,\n   addHighlight,\n   removeHighlights,\n} from \"./DomController\";\n\nexport const initApp = () => {\n   renderGameBoards(player1, player2);\n   renderShipPlacementBoard(player1);\n   randomlyPlaceCpuPlayerShips();\n};\n\nexport const handleShipClick = (row, col, player, clickType) => {\n   if (clickType === \"right\") {\n      vesselOrientation.swapVesselOrientation();\n   } else {\n      placeShips(row, col);\n      UpdateGameboardDOM(player);\n   }\n};\n\nexport const passGridContainer = () => getGridContainer();\n\nexport const callAddHighlight = (cell) => addHighlight(cell);\n\nexport const callUpdateGameboardDOM = (player) => UpdateGameboardDOM(player);\n\nexport const callHighlightShipPlacement = (row, col, player) =>\n   highlightShipPlacement(row, col, player);\n\nexport const callRemoveHighlights = (gridContainer) => removeHighlights(gridContainer);\n\nexport const handleCellClick = (row, col) => {\n   row = Number(row);\n   col = Number(col);\n   runGame(row, col);\n};\n\nexport const passCellDisplayInfo = (row, col, player, isOccupied) =>\n   updateCellContent(row, col, player, isOccupied);\n\nexport const gameOver = () => {\n   updateGameOver();\n};\n\nexport const updatePlacementUI = () => removePlacementOverlay();\n\nexport const passTurnInfo = (turnInfo) => updateDomOnTurn(turnInfo);\n\nexport const isTouchDevice = () => {\n   return window.matchMedia(\"(pointer: coarse)\").matches;\n};\n"],"names":["Ship","length","direction","startRow","startCol","hits","getHits","hit","isSunk","Gameboard","size","board","Array","from","fill","ships","getCell","row","col","hasShip","getShip","index","Number","isInteger","undefined","placeShip","i","_isValidPlacement","Error","ship","shipIndex","push","newCol","getAllShips","receiveAttack","cell","console","log","isAllShipsSunken","every","getGrid","getShipPositions","map","getShipIndex","find","Player","name","ownBoard","ShipPlacer","player","placeShipManually","error","message","placeShipsRandomly","armada","forEach","vessel","placed","attempts","randomDirection","Math","random","randomRow","floor","randomCol","type","cpuPlayer","state","lastHit","potentialTargets","attackedCells","Set","shipOrientation","attackDirection","currentShipLength","getState","setState","newState","getLastHit","setLastHit","coords","addPotentialTargets","targets","getNextTarget","shift","clearPotentialTargets","getPotentialTargets","markCellAsAttacked","add","hasCellBeenAttacked","has","getShipOrientation","setShipOrientation","orientation","getAttackDirection","setAttackDirection","getCurrentShipLength","setCurrentShipLength","resetCurrentShipLength","ComputerPlayer","player1","player2","vesselOrientation","getVesselOrientation","setVesselOrientation","swapVesselOrientation","currentShipIndex","resetComputerPlayer","addTargetsAlongOrientation","leftCol","rightCol","upRow","downRow","_getAdjacentCells","filter","_randomizeCoords","runGame","opponent","takeTurns","getCurrentPlayer","result","passCellDisplayInfo","gameOver","swapTurns","nextTurn","passTurnInfo","setTimeout","shipToCheck","handleHuntMode","nextTarget","nextRow","nextCol","lastRow","lastCol","currentDirection","handleTargetMode","handleCpuTurn","currentPlayer","isPlayerTurn","removeHighlights","gridContainer","querySelectorAll","classList","remove","UpdateGameboardDOM","originalGameboardElement","document","getElementById","popupGameboardElement","updateGameboardElement","gameboardElement","querySelector","isOccupied","_createGameBoardDOM","callback","customId","playerName","createElement","id","longPressTimer","colElement","dataset","addEventListener","event","button","preventDefault","clearTimeout","callHighlightShipPlacement","appendChild","callAddHighlight","addHighlight","callUpdateGameboardDOM","shipLength","callRemoveHighlights","targetRow","targetCol","highlightShipPlacement","handleCellClick","_getCellElement","updateCellContent","overlay","announcementCard","announcement","textContent","closeButton","location","reload","_displayGameOver","updatePlacementUI","removeChild","removePlacementOverlay","turnInfo","player1Board","player2Board","updateDomOnTurn","container","player1GameboardDOM","player2GameboardDOM","append","renderGameBoards","popup","messageHeading","messageBody","window","matchMedia","matches","gameBoardDOM","clickType","theShipOrientation","shipPlacer","placeShips","handleShipClick","closeBtn","renderShipPlacementBoard"],"sourceRoot":""}